#include "STileMap.h"namespace nimbus{  /* FUNCTION: TileMap constructor   * Top-level constructor for TileMap   * SHOULD DELEGATE LOWER FUNCTIONS   */  STileMap::STileMap(IrrlichtDevice* device): STileMap(device, core::dimension2df(1024.0f, 1024.0f), core::vector2d<u32>(10, 10)) {}    /* FUNCTION: TileMap constructor   * Lowest delegate.   *    * dimension2d<float> worldSize: Size of the world in map units, used for tile size generation.   * vector2d<int> tileCount: Number of tiles in this system. Defaults to 10, 10.   */  STileMap::STileMap(IrrlichtDevice* device, core::dimension2df worldSize, core::vector2d<u32> tileCount): worldSize(worldSize), tileCount(tileCount)  {    // SETUP DIMENSIONS TO U32    core::dimension2d<u32> realSize = core::dimension2d<u32>((u32)worldSize.Width, (u32)worldSize.Height);        // CREATE INITIAL TEXTURE    this->texture = device->getVideoDriver()->addTexture(realSize, std::string("tilemaptexture").c_str(), video::ECF_A8R8G8B8); // Note: Forces texture name, would cause conflict in multi-instance.        // SETUP TILE AND VECTOR FIELDS    this->tiles = new Tile**[tileCount.Y]; // Rows    this->vectorField = new core::vector2d<f32>**[tileCount.Y];        for(int row = 0; row < tileCount.Y; ++row) {      this->tiles[row] = new Tile*[tileCount.X];      this->vectorField[row] = new core::vector2d<f32>*[tileCount.X];            for(int col = 0; col < tileCount.X; ++col) {	this->tiles[row][col] = new Tile(device);	this->vectorField[row][col] = new core::vector2d<f32>(rand() % 10, rand() % 10);		this->vectorField[row][col]->normalize();      }    }  }    // DECONSTRUCTOR YEP  STileMap::~STileMap()  {    std::cerr << "!!!WARNING!!!" << std::endl << "MAKE SURE TILES ARE GETTING DEALLOCATED. THIS MESSAGE IS NTO TO BE REMOVED UNTIL THIS CHECK IS DONE AND CONFIRMED BY AT LEAST TWO DEVELOPERS." << std::endl << "!!!WARNING!!!" << std::endl;        for(int row = 0; row < this->tileCount.Y; ++row) {      for(int col = 0; col < this->tileCount.X; ++col) {	delete this->vectorField[row][col];	delete this->tiles[row][col]; // MAKE SURE TILES ARE GETTING DEALLOCATED PROPERLY      }            delete[] this->tiles[row];      delete[] this->vectorField[row];    }        delete[] this->tiles;    delete[] this->vectorField;  }    /* FUNCTION: getTexture   * Updates the internal texture and returns it.   *    * Yeah, that's pretty much it.   */  video::ITexture* getTexture(void)  {  }}