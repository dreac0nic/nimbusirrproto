#include "STileMap.h"namespace nimbus{  /* FUNCTION: TileMap constructor   * Top-level constructor for TileMap   * SHOULD DELEGATE LOWER FUNCTIONS   */  STileMap::STileMap(IrrlichtDevice* device): STileMap(device, core::dimension2df(1024.0f, 1024.0f), core::vector2d<u32>(10, 10)) {}    /* FUNCTION: TileMap constructor   * Lowest delegate.   *    * dimension2d<float> worldSize: Size of the world in map units, used for tile size generation.   * vector2d<int> tileCount: Number of tiles in this system. Defaults to 10, 10.   */  STileMap::STileMap(IrrlichtDevice* device, core::dimension2df worldSize, core::vector2d<u32> tileCount): worldSize(worldSize), tileCount(tileCount)  {    // SETUP DIMENSIONS TO U32    core::dimension2d<u32> realSize = core::dimension2d<u32>((u32)worldSize.Width, (u32)worldSize.Height);        // CREATE INITIAL TEXTURE    this->texture = device->getVideoDriver()->addTexture(realSize, std::string("tilemaptexture").c_str(), video::ECF_A8R8G8B8); // Note: Forces texture name, would cause conflict in multi-instance.        // SETUP TILE AND VECTOR FIELDS    this->tiles = new Tile**[tileCount.Y]; // Rows    this->vectorField = new core::vector2d<f32>**[tileCount.Y];        for(int row = 0; row < tileCount.Y; ++row) {      this->tiles[row] = new Tile*[tileCount.X];      this->vectorField[row] = new core::vector2d<f32>*[tileCount.X];            for(int col = 0; col < tileCount.X; ++col) {	this->tiles[row][col] = new Tile(device);	this->vectorField[row][col] = new core::vector2d<f32>(rand() % 10, rand() % 10);		this->vectorField[row][col]->normalize();      }    }  }    // DECONSTRUCTOR YEP  STileMap::~STileMap()  {    std::cerr << "!!!WARNING!!!" << std::endl << "MAKE SURE TILES ARE GETTING DEALLOCATED. THIS MESSAGE IS NTO TO BE REMOVED UNTIL THIS CHECK IS DONE AND CONFIRMED BY AT LEAST TWO DEVELOPERS." << std::endl << "!!!WARNING!!!" << std::endl;        for(int row = 0; row < this->tileCount.Y; ++row) {      for(int col = 0; col < this->tileCount.X; ++col) {	delete this->vectorField[row][col];	delete this->tiles[row][col]; // MAKE SURE TILES ARE GETTING DEALLOCATED PROPERLY      }            delete[] this->tiles[row];      delete[] this->vectorField[row];    }        delete[] this->tiles;    delete[] this->vectorField;  }    /* FUNCTION: getTexture   * Updates the internal texture and returns it.   *    * Yeah, that's pretty much it.   */  video::ITexture* STileMap::getTexture(void)  {    // CHECK TEXTURE INTEGRITY    if(!texture && texture->getColorFormat() != video::ECF_A8R8G8B8) {      std::cerr << "THIS TILEMAP IS GOIN' NO WHERE!" << std::endl;            return 0;    }        // SETUP    u32* data = static_cast<u32*>(texture->lock());    u32 color = 0xff000000;        // START TEXTURE GENERATION    for(u32 tileX = 0; tileX < this->tileCount.X; ++tileX) {      for(u32 tileY = 0; tileY < this->tileCount.Y; ++tileY) {	std::cerr << "Beginning Texture Generation for " << tileX << ", " << tileY << std::endl;		// Calculate tile offset using the tile size and current position.	u32 offset = tileX*tiles[tileX][tileY]->getSize().Width + tileY*tileCount.Y*tiles[tileX][tileY]->getSize().Height;		std::cerr << "LOOK TEXTURE GOOOOO!" << std::endl;	video::ITexture* tileTexture = tiles[tileX][tileY]->getTexture();		// Check Texture Integrity	if(!tileTexture && tileTexture->getColorFormat() != video::ECF_A8R8G8B8) {	  std::cerr << "IT'S DEAD JIM." << std::endl;	  	  return 0;	}		// Setup texture data	u8* tileData = static_cast<u8*>(tileTexture->lock());		// Write bunk tile data.	for(u32 u = 0; u < tiles[tileX][tileY]->getSize().Width*tiles[tileX][tileY]->getSize().Height; ++u) {	  data[offset + u] = tileData[u];	}		tileTexture->unlock();      }    }        // UNLOCK TEXTURE AND RETURN    this->texture->unlock();        return this->texture;  }}